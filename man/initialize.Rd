% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gGnome.R
\name{initialize}
\alias{initialize}
\alias{gNode}
\title{copy}
\description{
copy

copy

flip

terminal
}
\author{
Joe DeRose

Marcin Imielinski
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-gNode-new}{\code{gNode$new()}}
\item \href{#method-gNode-mark}{\code{gNode$mark()}}
\item \href{#method-gNode-rep}{\code{gNode$rep()}}
\item \href{#method-gNode-swap}{\code{gNode$swap()}}
\item \href{#method-gNode-subset}{\code{gNode$subset()}}
\item \href{#method-gNode-eval}{\code{gNode$eval()}}
\item \href{#method-gNode-clusters}{\code{gNode$clusters()}}
\item \href{#method-gNode-ego}{\code{gNode$ego()}}
\item \href{#method-gNode-print}{\code{gNode$print()}}
\item \href{#method-gNode-loose.degree}{\code{gNode$loose.degree()}}
\item \href{#method-gNode-clone}{\code{gNode$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gNode-new"></a>}}
\if{latex}{\out{\hypertarget{method-gNode-new}{}}}
\subsection{Method \code{new()}}{
Set up the constructor GNODE
index - snode.id
graph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gNode$new(snode.id = NULL, graph)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{snode.id}}{signed node id}

\item{\code{graph}}{gGraph associated with this sNode}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gNode-mark"></a>}}
\if{latex}{\out{\hypertarget{method-gNode-mark}{}}}
\subsection{Method \code{mark()}}{
Marks the nodes pointed at by this gNode by adding metadata in the gGraph they came from.
Metadata names can be arbitrary, such as "lwd = 7" or "highlight = TRUE".
gGraph nodes have metadata specified appended to them
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gNode$mark(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{metadata names = data to store in metadata columns}

\item{\code{...}}{name = value pairs of scalar or vector (length edges in graph) arguments
```}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
```
gg$nodes[1:5]$mark(col = "purple")
gg$nodes$mark(changed = FALSE)
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gNode-rep"></a>}}
\if{latex}{\out{\hypertarget{method-gNode-rep}{}}}
\subsection{Method \code{rep()}}{
Creates "bubbles" in the graph by replicating the nodes in the argument.  Node replication
replicates edges going in and out of all replicated nodes.  If an edge connects a pair of replicated nodes
that edge will be replicated across all pairs of those replciated nodes.   Walk replication will create "longer bubbles"
with fewer edges getting replicated i.e. it will only replicate intra-walk edges within each walk replicate (but not between
separate walk replicates).

New graph keeps track of the parent node and edge ids in the original graph using node metadata parent.node.id
and edge metadata parent.edge.id i.e. the replicated nodes will be connected to the sources of the original nodes
and if replicated nodes connect to each other, then there will exist an edge connecting
all of their instances to each other.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gNode$rep(times)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{times}}{scalar or vector of length self$length specifying how many times to replicate each of the nodes.}

\item{\code{nodes}}{= gNode object must point to a node in the graph, can also be an index of a node (but not a metadata expression), can also be a gWalk object}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Returns a pointer to the new nodes
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gNode-swap"></a>}}
\if{latex}{\out{\hypertarget{method-gNode-swap}{}}}
\subsection{Method \code{swap()}}{
Swap nodes with granges, grl, or Gwalks.
Provided replacement vector must be the same length as the inputted nodes, resulting in each node being "swapped" by the provided 
interval, node, grl (representing a walk), or gWalk.  The replacement will inherit left and right edges for the removed node.
If the replacement is a walk, then the left side of the first node in the walk will inherit the edges that were
previously to the left of the node being replaced, and right side of the last node of the walk will inherit the edges
that were previously to the right of the node being replaced.  

Note: these replacement obey the orientation of the arguments.  So if the node to be replaced is flipped (- orientation with
respect to the reference, then it's "left" is to the right on the reference.  Similarly for walks whose first interval
is flipped with respect to the reference, the left edges will be attached to the right of the node on the reference.)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gNode$swap(replacement)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{replacement}}{GRanges, GRangesList, or gWalk object whose length is the length(nodes)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
gGraph (also modified in place) with nodes annotated with parent.node.id, parent.rep
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gNode-subset"></a>}}
\if{latex}{\out{\hypertarget{method-gNode-subset}{}}}
\subsection{Method \code{subset()}}{
Allows subseting of the Node object using bracket notation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gNode$subset(i)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{integer or logical index}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
subset of nodes indexed by i
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gNode-eval"></a>}}
\if{latex}{\out{\hypertarget{method-gNode-eval}{}}}
\subsection{Method \code{eval()}}{
Evaluates expression over edge metadata for all nodes in self
with a keyby node.id returning a self$length vector
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gNode$eval(x, right = TRUE, all = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{expression over edge metadata
value for "cluster"}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gNode-clusters"></a>}}
\if{latex}{\out{\hypertarget{method-gNode-clusters}{}}}
\subsection{Method \code{clusters()}}{
Marks nodes in graph with metadata field $cluster
based on one of several algorithms, selected by mode.

Unlike the gGraph version of this function, this usage enables computation of clusters
based on a subset of nodes in the graph (i.e. ignoring certain nodes)
while still marking the original graph (and leaving the excluded graph with an NA)
value for "cluster"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gNode$clusters(mode = "weak")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{weak}}{character scalar that can take one of the following possible values - "weak" or "strong" specifying weakly or strongly connected components, walktrap specifying cluster_walktrap community detection}

\item{\code{weak}}{character scalar that can take one of the following possible values - "weak" or "strong" specifying weakly or strongly connected components, walktrap specifying cluster_walktrap community detection}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gNode-ego"></a>}}
\if{latex}{\out{\hypertarget{method-gNode-ego}{}}}
\subsection{Method \code{ego()}}{
returns all nodes with k degrees of separation (i.e. "order")
from these
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gNode$ego(order = 0, mindist = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{order}}{integer edge distance from these (seed) nodes to return}

\item{\code{mindist}}{minimum distance from these (seed) nodes}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
gNode object comprising nodes within the ego of this node
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gNode-print"></a>}}
\if{latex}{\out{\hypertarget{method-gNode-print}{}}}
\subsection{Method \code{print()}}{
Prints out the gNode Object. Prints the length and the GRanges of the nodes.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gNode$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gNode-loose.degree"></a>}}
\if{latex}{\out{\hypertarget{method-gNode-loose.degree}{}}}
\subsection{Method \code{loose.degree()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gNode$loose.degree(orientation)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{orientation}}{(character) one of 'left' or 'right'}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
number of loose ends with given orientation
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gNode-clone"></a>}}
\if{latex}{\out{\hypertarget{method-gNode-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gNode$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
