% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gGnome.R
\name{gGraph constructor}
\alias{gGraph constructor}
\alias{gGraph}
\title{simplify}
\description{
simplify

simplify

reduce
}
\author{
Joe DeRose

Marcin Imielinski

Xiaotong Yao

Joe DeRose, Marcin Imielinski
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-gGraph-new}{\code{gGraph$new()}}
\item \href{#method-gGraph-walks}{\code{gGraph$walks()}}
\item \href{#method-gGraph-set}{\code{gGraph$set()}}
\item \href{#method-gGraph-queryLookup}{\code{gGraph$queryLookup()}}
\item \href{#method-gGraph-disjoin}{\code{gGraph$disjoin()}}
\item \href{#method-gGraph-simplify}{\code{gGraph$simplify()}}
\item \href{#method-gGraph-reduce}{\code{gGraph$reduce()}}
\item \href{#method-gGraph-subgraph}{\code{gGraph$subgraph()}}
\item \href{#method-gGraph-clusters}{\code{gGraph$clusters()}}
\item \href{#method-gGraph-eclusters}{\code{gGraph$eclusters()}}
\item \href{#method-gGraph-eclusters2}{\code{gGraph$eclusters2()}}
\item \href{#method-gGraph-paths}{\code{gGraph$paths()}}
\item \href{#method-gGraph-dist}{\code{gGraph$dist()}}
\item \href{#method-gGraph-rep}{\code{gGraph$rep()}}
\item \href{#method-gGraph-swap}{\code{gGraph$swap()}}
\item \href{#method-gGraph-connect}{\code{gGraph$connect()}}
\item \href{#method-gGraph-toposort}{\code{gGraph$toposort()}}
\item \href{#method-gGraph-print}{\code{gGraph$print()}}
\item \href{#method-gGraph-annotate}{\code{gGraph$annotate()}}
\item \href{#method-gGraph-maxflow}{\code{gGraph$maxflow()}}
\item \href{#method-gGraph-window}{\code{gGraph$window()}}
\item \href{#method-gGraph-gtrack}{\code{gGraph$gtrack()}}
\item \href{#method-gGraph-trim}{\code{gGraph$trim()}}
\item \href{#method-gGraph-fix}{\code{gGraph$fix()}}
\item \href{#method-gGraph-add}{\code{gGraph$add()}}
\item \href{#method-gGraph-json}{\code{gGraph$json()}}
\item \href{#method-gGraph-get.diameter}{\code{gGraph$get.diameter()}}
\item \href{#method-gGraph-circos}{\code{gGraph$circos()}}
\item \href{#method-gGraph-split}{\code{gGraph$split()}}
\item \href{#method-gGraph-clone}{\code{gGraph$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-new"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-new}{}}}
\subsection{Method \code{new()}}{
All purpose constructor of gGraphs from
nodes, edges, junctions or various input formats (JaBbA, Weaver, etc)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$new(
  genome = NULL,
  breaks = NULL,
  juncs = NULL,
  alignments = NULL,
  prego = NULL,
  jabba = NULL,
  cougar = NULL,
  weaver = NULL,
  remixt = NULL,
  rck = NULL,
  walks = NULL,
  nodes = NULL,
  edges = NULL,
  nodeObj = NULL,
  edgeObj = NULL,
  meta = NULL,
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{genome}}{Seqinfo or object coercible to seqinfo}

\item{\code{breaks}}{GRanges whose endpoints specify breakpoints in the genome}

\item{\code{juncs}}{Junction object or GRangesList coercible to Junction}

\item{\code{prego}}{PREGO output directory path}

\item{\code{jabba}}{JaBbA graph rds file}

\item{\code{cougar}}{CouGar output directory path}

\item{\code{weaver}}{Weaver output directory path}

\item{\code{remixt}}{RemiXT output directory path}

\item{\code{rck}}{RCK output directory path}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-walks"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-walks}{}}}
\subsection{Method \code{walks()}}{
Exhaustively generates walks (if greedy = FALSE)
or otherwise applies a greedy heuristic (greedy = TRUE)
returns a gWalk object tied to this graph
warning: greedy = FALSE will not scale to large graphs
(i.e. may even hang on a couple of hundred nodes, depending
on the topology)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$walks(field = NULL, greedy = FALSE, verbose = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{greedy}}{logical scalar specifying whether to generate greedy walks}

\item{\code{verbose}}{logical scalar}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-set"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-set}{}}}
\subsection{Method \code{set()}}{
set metadata of gGraph
right now mainly useful for gTrack defaults
such as "name" or "colormaps", and also used
for setting default "by" field for simplify
but can be used for configuring other settings in the future
(note that this is graph level and not gNode or gEdge level
metadata)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$set(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{...}}{name value pairs}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-queryLookup"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-queryLookup}{}}}
\subsection{Method \code{queryLookup()}}{
Returned a data.table of the provided snode.ids, their indicies and the indicies of
their reverse complements in the graph. data.table is keyed on snode.id.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$queryLookup(id)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{id}}{snode.ids to look up}

\item{\code{id}}{signed node ids in graph}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
data.table of snode.ids, indicies and reverse complement indicies
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-disjoin"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-disjoin}{}}}
\subsection{Method \code{disjoin()}}{
disjoins (i.e. collapses) all overlapping nodes in graph (subject to "by" argument), and aggregates node and edge
metadata among them using FUN
modifies the current graph
optional input gr will first concatenate a reference graph with GRanges gr prior to disjoining
collapse argument (if TRUE) will output a graph where there is a single
node per reference interval
and if collapse = FALSE will only disjoin all the nodes in the graph but keep all overlapping nodes separate
i.e. so that overlapping graphs are composed of a common set of disjoint intervals, but we allow there 
to be several instances of a given interval among the different graphs
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$disjoin(
  gr = NULL,
  by = NULL,
  collapse = TRUE,
  na.rm = TRUE,
  avg = FALSE,
  sep = ",",
  FUN = default.agg.fun.generator(na.rm = na.rm, sep = sep, avg = avg)
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{gr}}{GRanges around which to disjoin the graph}

\item{\code{by}}{metadata field of current graph around which to limit disjoining}

\item{\code{collapse}}{logical scalar specifying whether to collapse graph nodes after disjoining}

\item{\code{na.rm}}{logical scalar specifying whether to remove NA's when aggregating metadata after collapsing}

\item{\code{avg}}{logical scalar specifying whether to average (if TRUE) or sum (if FALSE) numeric metadata during aggregation (default = FALSE)}

\item{\code{FUN}}{function which should take (numeric or character) x and na.rm = TRUE and return a scalar value}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-simplify"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-simplify}{}}}
\subsection{Method \code{simplify()}}{
Simplifies gGraph by collapsing reference adjacent nodes
that lack a junction or loose end (ignore.loose = FALSE)
between them.

Takes an optional "by" column. If by is not NULL simplify
will only collapse adjacent nodes if they share metadata
in the columns specified by "by"
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$simplify(
  by = private$pmeta$by,
  na.rm = TRUE,
  avg = TRUE,
  sep = ",",
  FUN = default.agg.fun.generator(na.rm = na.rm, sep = sep, avg = avg),
  ignore.loose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{by}}{metadata field of current graph around which to limit simplification}

\item{\code{na.rm}}{logical scalar specifying whether to remove NA's when aggregating metadata after collapsing}

\item{\code{avg}}{logical scalar specifying whether to average (if TRUE) or sum (if FALSE) numeric metadata during aggregation (default = FALSE)}

\item{\code{FUN}}{function which should take (numeric or character) x and na.rm = TRUE and return a scalar value}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-reduce"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-reduce}{}}}
\subsection{Method \code{reduce()}}{
Reduces graph which is $disjoin() followed by a simplify()$
i.e. collapsing overlapping nodes, then merging
adjacent ones subject to (optional) matching on some
metadata field
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$reduce(...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{by}}{metadata field of current graph around which to limit reduction (i.e. disjoining and simplification)}

\item{\code{na.rm}}{logical scalar specifying whether to remove NA's when aggregating metadata after collapsing}

\item{\code{avg}}{logical scalar specifying whether to average (if TRUE) or sum (if FALSE) numeric metadata during aggregation (default = FALSE)}

\item{\code{FUN}}{function which should take (numeric or character) x and na.rm = TRUE and return a scalar value}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-subgraph"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-subgraph}{}}}
\subsection{Method \code{subgraph()}}{
compute subgraph within a certain distance or degree of separation 
of (all nodes) intersection given GRanges "seed" window win
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$subgraph(
  seed = si2gr(self),
  d = NULL,
  k = 0,
  bagel = FALSE,
  mod = FALSE,
  ignore.strand = T,
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{seed}}{GRanges around which to subgraph}

\item{\code{d}}{distance in bp around which to subgraph}

\item{\code{k}}{order in number of edges which to subgraph}

\item{\code{ignore.strand}}{logical scalar specifying whether to ignore.strand}

\item{\code{verbose}}{logical scalar}

\item{\code{pad}}{positive integer scalar padding to add to seed}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-clusters"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-clusters}{}}}
\subsection{Method \code{clusters()}}{
Marks nodes in graph with metadata field $cluster
based on one of several algorithms, selected by mode
If i and j are specified, graph is first subsetted then 
clusters computed, then cluster ids are lifted back to mark
the original graph.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$clusters(i = NULL, j = NULL, mode = "weak")}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{i}}{node filter to apply to graph prior to clustering}

\item{\code{j}}{edge filter to apply to graph prior to clustering}

\item{\code{weak}}{character scalar that can take one of the following possible values - "weak" or "strong" specifying weakly or strongly connected components, walktrap specifying cluster_walktrap community detection}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-eclusters"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-eclusters}{}}}
\subsection{Method \code{eclusters()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$eclusters(
  thresh = 1000,
  range = 1e+06,
  weak = TRUE,
  paths = !weak,
  mc.cores = 1,
  verbose = FALSE,
  chunksize = 1e+30,
  method = "single"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{thresh}}{the distance threshold with which to group nearby quasi-reciprocal junctions - i.e. if thresh=0 then we only consider clusters of exactly reciprocal junctions.}

\item{\code{weak}}{logical flag if TRUE will not differentiate between cycles and paths and will return all weakly connected clusters in the graph [FALSE]}

\item{\code{mc.cores}}{parallel}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
numerical vector of the same length, Inf means they r not facing each other
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-eclusters2"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-eclusters2}{}}}
\subsection{Method \code{eclusters2()}}{
Marks ALT edges belonging (quasi) reciprocal cycles
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$eclusters2(
  thresh = 1000,
  range = 1e+06,
  weak = TRUE,
  paths = !weak,
  mc.cores = 1,
  verbose = FALSE,
  chunksize = 1e+30,
  method = "single",
  return_pairs = FALSE,
  ignore.small = TRUE,
  max.small = 10000,
  ignore.isolated = TRUE,
  strict = c("strict", "one_to_one", "loose"),
  min.isolated = max.small,
  only_chains = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{weak}}{logical flag if TRUE will not differentiate between cycles and paths and will return all weakly connected clusters in the junction graph [FALSE]}

\item{\code{mc.cores}}{parallel}

\item{\code{max.small}}{size below which simple dups and dels are excluded}

\item{\code{only_chains}}{TRUE will only pair breakend to its nearest nearest neighbor IFF the nearest neighbor is reciprocal}

\item{\code{juncs}}{GRangesList of junctions}

\item{\code{ignore.strand}}{usually TRUE}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
numerical vector of the same length, Inf means they r not facing each other
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-paths"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-paths}{}}}
\subsection{Method \code{paths()}}{
Returns shortest paths from query gNode to subject gNode in graph in the form of gWalks
(note: the gNodes must exist in the graph, unlike in the related but more general proximity function)

Each output path is a  gWalk that connects query-subject on the genome
described by gGraph gg.  Each gWalk is  annotated by the metadata of the
corresponding query-subject GRanges pair as well as fields "altdist" and "refdist"
specifying the "alternate and "reference" gGraph distance of the
query-subject pair.  The gWalk metadata field "reldist" specifies 
the relative distance (i.e. ratio of altdist to refdist) for that walk.

NOTE: this operation can be quite expensive for large combinations of
of query and subject, so max.dist parameter will by default only compute
paths for query-subject pairs that are less then max.dist apart (default 1MB).
That default is chosen for large queries (eg >10K on each side), however
for smaller queries (eg length <100) the user may want to set max.dist = Inf

By default performs a "cartesian" search, i.e. all pairs of query and subject
but if cartesian is set to FALSE will only search for specified pairs of query
and subject (then query and subject must be of the same length)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$paths(
  query,
  subject = query,
  mc.cores = 1,
  weight = NULL,
  meta = NULL,
  ignore.strand = TRUE,
  cartesian = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{query}}{gNode object or snode.id of gNode in this graph}

\item{\code{subject}}{gNode object or snode.id of gNode in this graph}

\item{\code{mc.cores}}{how many cores (default 1)}

\item{\code{weight}}{edge column to use as the weight (instead of standard weight column)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
gWalk object each representing a query-subject shortest path (if any exist)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-dist"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-dist}{}}}
\subsection{Method \code{dist()}}{
Computes a distance matrix of query and subject
intervals (in base pairs) on the gGraph
between any arbitrary pairs of granges gr1 and gr2.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$dist(
  query,
  subject,
  weight = NULL,
  ignore.strand = TRUE,
  include.internal = TRUE,
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{weight}}{metadata field of gEdges to use as weight (instead of distance of target node)}

\item{\code{include.internal}}{logical flag whether to allow
paths that begin or end inside teh query or subject}

\item{\code{gr1}}{GRanges query}

\item{\code{gr2}}{GRanges query (if NULL, will set to gr1)}

\item{\code{dt}}{returns data.table if TRUE, excluding all Inf distances}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-rep"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-rep}{}}}
\subsection{Method \code{rep()}}{
Creates "bubbles" in the graph by replicating the nodes or gwalks in the argument.  Node replication
replicates edges going in and out of all replicated nodes.  If an edge connects a pair of replicated nodes
that edge will be replicated across all pairs of those replciated nodes.   Walk replication will create "longer bubbles"
with fewer edges getting replicated i.e. it will only replicate intra-walk edges within each walk replicate (but not between
separate walk replicates).

(note that this changes the current gGraph in place, and thus the input gNode or gWalk will no longer
apply to the new altered gWalk)

New graph keeps track of the parent node and edge ids in the original graph using node metadata parent.node.id
and edge metadata parent.edge.id i.e. the replicated nodes will be connected to the sources of the original nodes
and if replicated nodes connect to each other, then there will exist an edge connecting
all of their instances to each other.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$rep(nodes = NULL, times)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nodes}}{= gNode object must point to a node in the graph, can also be an index of a node (but not a metadata expression), can also be a gWalk object}

\item{\code{times}}{scalar or vector of length self$length specifying how many times to replicate each of the nodes.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
gGraph (also modified in place) with nodes annotated with parent.node.id, parent.rep
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-swap"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-swap}{}}}
\subsection{Method \code{swap()}}{
Swap nodes with granges, grl, or Gwalks.
Provided replacement vector must be the same length as the inputted nodes, resulting in each node being "swapped" by the provided 
interval, node, grl (representing a walk), or gWalk.  The replacement will inherit left and right edges for the removed node.
If the replacement is a walk, then the left side of the first node in the walk will inherit the edges that were
previously to the left of the node being replaced, and right side of the last node of the walk will inherit the edges
that were previously to the right of the node being replaced.  

Note: these replacement obey the orientation of the arguments.  So if the node to be replaced is flipped (- orientation with
respect to the reference, then it's "left" is to the right on the reference.  Similarly for walks whose first interval
is flipped with respect to the reference, the left edges will be attached to the right of the node on the reference.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$swap(nodes, replacement)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nodes}}{= gNode object must point to a node in this graph, can also be an index of a node (but not a metadata expression), can also be a gWalk object}

\item{\code{replacement}}{GRanges, GRangesList, or gWalk object whose length is the length(nodes)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
gGraph (also modified in place) with nodes annotated with parent.node.id, parent.rep
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-connect"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-connect}{}}}
\subsection{Method \code{connect()}}{
Connect node pairs in the gGraph by adding (optional) edge metadata and (optionally) inserting nodes or grl / walks
in between the given edge.  Note: the connections are made with respect to the provided node orientation
so if the node is provided in a "flipped" orientation then it's right direction will point left on the reference.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$connect(
  n1,
  n2,
  n1.side = "right",
  n2.side = "left",
  type = "ALT",
  meta = NULL,
  insert = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n1}}{= gNode object must point to a node in this graph, can also be an index of a node (but not a metadata expression), can also be a gWalk object}

\item{\code{n2}}{= gNode object must point to a node in this graph, can also be an index of a node (but not a metadata expression), can also be a gWalk object}

\item{\code{n1.side}}{character vector of length length(n1) whose value is either "left" or "right" (default 'right')}

\item{\code{n2.side}}{character vector of length length(n1) whose value is either "left" or "right" (default 'left')}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
gGraph (also modified in place) with nodes annotated with parent.node.id, parent.rep
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-toposort"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-toposort}{}}}
\subsection{Method \code{toposort()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$toposort()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
current graph, modified with nodes marked according to topological sort
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-print"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-print}{}}}
\subsection{Method \code{print()}}{
Prints out this gGraph. Prints number of nodes and edges, the gNode associated
with this gGraph and the gEdge associated with this gGraph
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-annotate"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-annotate}{}}}
\subsection{Method \code{annotate()}}{
Used by the mark() functions in gNode, gEdge and gWalks to alter the metadata
associated with the nodes and edges in this gGraph. Not recommended to use this
function. It is much safer to use mark.

FYI
id for nodes is the node.id (not snode.id)
id for edges is the edge.id (not sedge.id)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$annotate(colName, data, id, class)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-maxflow"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-maxflow}{}}}
\subsection{Method \code{maxflow()}}{
Computes the "max flow" between every node pair in self
for some metadata field.  

The "max flow" for a node pair i, j is the
maximum value m of node and/or edge metadata for which there
exists a path p between i and j whose nodes n and/or edges e
obey field(n)>=m and/or field(e)>=m for all n,e \eqn{\in} p.
(i.e. m is the maximum lower bound of the value of
nodes / edges across all paths connecting ij)

The "min version" of this problem (max = FALSE) will 
determine the min value m for which there exists  p
whose nodes n and edges e
obey field(n)>=m and/or field(e)>=m for all n,e \eqn{\in} p.

The user can also do the problem with lower.bound = FALSE
i.e. where m is the (maximum or minimum) <upper> bound 
value in each path. 

By default will try to solve problem across both node and
edge metadata if the field is present in either.  If the field
is only present in one then will solve for that.  This property
can be toggled using edges.only and nodes.only parameters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$maxflow(
  field = NA,
  walk = FALSE,
  max = TRUE,
  lower.bound = TRUE,
  nfield = NA,
  efield = NA,
  cfield = NA,
  path.only = TRUE,
  require.nodes = NULL,
  multi = FALSE,
  ncopies = 1,
  reverse.complement = FALSE,
  verbose = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{field}}{metadata field to run maxflow on}

\item{\code{walk}}{if TRUE will return the single walk that maximizes the sum of metadata fields}

\item{\code{max}}{logical flag whether to find maximum path or (if max = FALSE) minimum path}

\item{\code{nfield}}{field to specify a node field to maximize across paths}

\item{\code{efield}}{field to specify an edge field to maximize across paths}

\item{\code{cfield}}{field to specify a node / edge field that limits / caps  the dosage at nodes / edges}

\item{\code{path.only}}{logical flag relevant only if walk = TRUE,  if path is TRUE will only allow path based maxflows (TRUE) ie will not return a solution when the graph contains only cycles}

\item{\code{multi}}{logical flag (FALSE) if TRUE will allow the optimization to compute a solution that outputs multiple disjoint paths}

\item{\code{ncopies}}{positive integer representing the number of copies of the flow that we want the graph to support}

\item{\code{reverse}}{complement will compute maximum flow between each node i and the reverse complement of node j in a strand specific way}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-window"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-window}{}}}
\subsection{Method \code{window()}}{
Returns the region this gGraph spans as a GRanges
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$window(pad = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pad}}{A positive amount to pad the window by}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
GRanges of the region this gGraph covers
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-gtrack"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-gtrack}{}}}
\subsection{Method \code{gtrack()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$gtrack(
  y.field = NULL,
  lwd.loose = 3,
  col.loose = alpha("blue", 0.6),
  col.alt = alpha("red", 0.4),
  ...
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-trim"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-trim}{}}}
\subsection{Method \code{trim()}}{
Trims the current gGraph to the provided GRanges and returns this as a new
gGraph.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$trim(tile)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{tile}}{GRanges to trim on}

\item{\code{tile}}{interval around which to trim the gGraph}

\item{\code{mod}}{Defaults to FALSE, set to TRUE to modify this gGraph}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
```
gr = c(GRanges("1", IRanges(10000,100000), "+"), GRanges("2", IRanges(10000,100000), "+"))
new.gg = gg$trim(gr)
```
}

\subsection{Returns}{
new gGraph trimmed to tile, unless mod is set to TRUE
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-fix"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-fix}{}}}
\subsection{Method \code{fix()}}{
Modifies (in place) the current seqlevels of the gGraph, including
keeping only certain seqlevels, dropping certain seqlevels, and replacing seqlevels.

Warning: this may modify the graph including getting rid of nodes and edges (i.e. those outside
the retained seqlevels) and also change coordinates (ie move ranges that were previously on different
chromosomes to the same chromosome etc.).  Use with caution!

Default behavior is to replace 'chr', with ''.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$fix(pattern = NULL, replacement = NULL, drop = TRUE, seqlengths = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pattern}}{character pattern to replace in seqlevels (used in a gsub, can have backreferences)}

\item{\code{replacement}}{character to replace pattern with (used in a gsub, can have backreferences)}

\item{\code{drop}}{character vector of seqlevels to drop or logical TRUE to drop all seqlevels that are unused  (TRUE)}

\item{\code{seqlengths}}{new seqlengths i.e. named integer vector of seqlevels to drop or embed graph into}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
current graph modified in place with additional nodes and edges, as specified by user
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-add"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-add}{}}}
\subsection{Method \code{add()}}{
Adds GRanges nodes, edges (data.table), or junctions to graph
Only one of the below parameters can be specified at a time (since
the graph is modified in place, order matters)
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$add(nodes = NULL, edges = NULL, junctions = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nodes}}{GRanges, strand is ignored}

\item{\code{edges}}{data.table specifying edges in existing table with field n1, n2, n1.side, n2.side}

\item{\code{junctions}}{Junction object or GRangesList coercible to junction object}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
current graph modified in place with additional nodes and edges, as specified by user
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-json"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-json}{}}}
\subsection{Method \code{json()}}{
Creates a json file for active visualization using gGnome.js
annotations are node / edge features that will be dumped to json
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$json(
  filename = ".",
  maxcn = 100,
  maxweight = 100,
  save = TRUE,
  verbose = FALSE,
  annotations = NULL,
  nfields = NULL,
  efields = NULL,
  settings = list(y_axis = list(title = "copy number", visible = TRUE)),
  cid.field = NULL,
  no.y = FALSE,
  offset = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{filename}}{character path to save to}

\item{\code{save}}{whether to save or return list object representing json contents}

\item{\code{annotations}}{which graph annotations to dump to json}

\item{\code{nfields}}{which node fields to dump to json (NULL)}

\item{\code{efields}}{which edge fields to dump to json (NULL)}

\item{\code{settings}}{gGnome.js settings values to add to the output JSON files (list)}

\item{\code{cid.field}}{field in the graph edges that should be used for setting the cid values in the JSON (default: 'sedge.id'). 
This is useful for cases in which there is some unique identifier used across samples to identify 
identical junctions (for example "merged.ix" field, which is generated by merge.Junction())}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-get.diameter"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-get.diameter}{}}}
\subsection{Method \code{get.diameter()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$get.diameter(weights = NULL)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-circos"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-circos}{}}}
\subsection{Method \code{circos()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$circos(...)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-split"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-split}{}}}
\subsection{Method \code{split()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$split(by = "parent.graph")}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gGraph-clone"></a>}}
\if{latex}{\out{\hypertarget{method-gGraph-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{gGraph$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
